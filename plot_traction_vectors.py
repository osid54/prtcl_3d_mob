import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
import re
import sys

# --- Configuration ---
# Files generated by the automated workflow
CSV_FILE = "solution_vector.csv"
OUT_FILE = "prtcl_3d_mob.out"

CURRENT_WALL_POS = None

def extract_collocation_points(out_filename, num_elements):
    """
    Parses prtcl_3d_mob.out to find the coordinates of the 
    Collocation Points (element centers).
    
    The structure is: 
    - Element Vertices (6 nodes * 3 coords * M elements)
    - Element Areas (1 value * M elements)
    - Collocation Points (1 coord set * M elements) <-- We need these!
    """
    print(f"1. Reading collocation points from {out_filename}...")
    
    if not os.path.exists(out_filename):
        print(f"ERROR: File not found: {out_filename}. Did the Fortran simulation run successfully?")
        return None

    try:
        # 1. Read the file content
        with open(out_filename, 'r') as f:
            # Read the first line (which contains the integer Nelm)
            f.readline()
            
            # Read the rest of the file content
            content = f.read() 

        # 2. Extract ALL floating-point numbers from the content
        # Use a very broad and robust regex to catch all floats
        all_floats = re.findall(r"[-+]?\d+\.\d+(?:E[-+]?\d+)?", content) 

        # Total expected number of floating-point data elements written 
        # AFTER the initial Nelm header: 
        # (6 nodes * 3 coords) + (1 area) + (3 collocation coords) = 22 floats per element
        num_expected_per_element = (6 * 3) + 1 + 3  # = 22
        
        # Calculate the total expected number of floats (excluding the Nelm header)
        num_expected_floats = num_expected_per_element * num_elements

        # The coordinates we want are the last 3 * M numbers in the Fortran's data output.
        # Calculation: 3 coordinates (x, y, z) * M elements
        num_collocation_coords = 3 * num_elements

        if len(all_floats) < num_expected_floats:
            print(f"ERROR: Insufficient data found in {out_filename}.")
            print(f"Expected at least {num_expected_floats} floats based on {num_elements} elements.")
            print(f"Found only {len(all_floats)} floats. The file is likely truncated.")
            return None

        # 3. Extract the Collocation Points (The last 3*M numbers in the list)
        collocation_floats = np.array(all_floats[-num_collocation_coords:], dtype=float)

        # 4. Reshape into a (M, 3) array
        collocation_points = collocation_floats.reshape(num_elements, 3)
        
        print(f"   -> Successfully extracted {num_elements} collocation points.")
        return collocation_points

    except Exception as e:
        print(f"An unexpected error occurred during file parsing: {e}")
        return None

def visualize_traction(collocation_points, traction_data, wall_pos_value):
    """
    Generates a 3D scatter plot of the particle surface with traction vectors,
    including the wall distance as an annotation.
    """
    print("2. Generating 3D visualization...")
    
    # Calculate the gap for the annotation (assuming particle center cy=1.0)
    gap_distance = 1.0 - wall_pos_value 

    SUMMARY_FILE = "mobility_summary.csv"
    
    # Read all mobility data
    try:
        mobility_df = pd.read_csv(SUMMARY_FILE)
        # Filter the DataFrame to find the row corresponding to the current wall position
        # Use a tolerance for float comparison
        target_row = mobility_df[np.isclose(mobility_df['Wall_Position'], wall_pos_value)].iloc[0]
        
        U_x, U_y, U_z = target_row[['Ux', 'Uy', 'Uz']].values
        Omega_z = target_row['Oz'] # Assuming rotation is mainly Oz
        
        velocity_text = (
            f"Linear Velocity (Ux): {U_x:.5e}\n"
            f"Angular Velocity (Oz): {Omega_z:.5e}"
        )
        
    except Exception:
        velocity_text = "Velocity Data N/A"
        U_x, U_y, U_z = 0.0, 0.0, 0.0 # Use zero velocity if extraction fails

    # Set up the figure and 3D axes
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')
    
    # -----------------------------------------------------
    # 1. Plot the Collocation Points (Particle Surface)
    # -----------------------------------------------------
    # Scatter plot of the point centers defines the shape of the particle
    ax.scatter(
        collocation_points[:, 0], 
        collocation_points[:, 1], 
        collocation_points[:, 2], 
        c='black', 
        marker='.', 
        label='Element Center (Collocation Point)'
    )
    
    # -----------------------------------------------------
    # 2. Plot the Traction Vectors (Force Field)
    # -----------------------------------------------------
    # Unpack the traction vector data (fx, fy, fz)
    F_x = traction_data['Traction_X'].values
    F_y = traction_data['Traction_Y'].values
    F_z = traction_data['Traction_Z'].values
    
    # Normalize the vectors for display purposes 
    # (Plotting actual values may be too messy or too small)
    magnitude = np.sqrt(F_x**2 + F_y**2 + F_z**2)
    # Use a small number to avoid division by zero if all forces are zero
    epsilon = 1e-10 
    
    # Normalized vector components (Q) for direction visualization
    Q_x = F_x / (magnitude + epsilon)
    Q_y = F_y / (magnitude + epsilon)
    Q_z = F_z / (magnitude + epsilon)
    
    # Scale the length of the vectors visually (e.g., length=0.1)
    scale = 0.1 
    
    # Plotting the vectors (Quiver plot) 
    if len(traction_data) == 0:
        print("\nWARNING: Traction data is empty. Only plotting particle geometry.")
    else:
        ax.quiver(
            collocation_points[:, 0], collocation_points[:, 1], collocation_points[:, 2], # Starting positions (U)
            Q_x * scale, Q_y * scale, Q_z * scale, # Direction and scaled length (V)
            color='red', 
            length=1, # Length argument is a multiplier on the scaled vectors
            arrow_length_ratio=0.2,
            label='Fluid Traction Vector (Scaled)'
        )

    # -----------------------------------------------------
    # 3. Finalize Plot
    # -----------------------------------------------------
    
    # Set labels and title
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    # Add a title specific to the run
    ax.set_title('Fluid Traction Field on Particle Surface')
    
    annotation_text = (
        f"Wall Position (y): {wall_pos_value:.2f}\n"
        f"Surface Gap ($\delta$): {gap_distance:.2f}\n"
        f"---------------------------\n"
        f"{velocity_text}"
    )

    ax.text2D(0.05, 0.85, # Adjusted position slightly for longer text
              annotation_text, 
              transform=ax.transAxes, 
              bbox=dict(facecolor='white', alpha=0.7))
    
    ax.legend()
    ax.set_aspect('equal', adjustable='box')
    
    # Save the plot
    plot_filename = 'traction_visualization.png'
    plt.savefig(plot_filename)
    print(f"   -> Visualization saved as {plot_filename}")
    print("   -> To view the image, you may need to open it from your Windows file system.")

def main():
    if not os.path.exists(CSV_FILE) or not os.path.exists(OUT_FILE):
        print(f"ERROR: Missing data files ({CSV_FILE} or {OUT_FILE}).")
        print("Please ensure you have successfully run the automated workflow script (`run_and_extract.py`).")
        return

    if len(sys.argv) < 2:
        print("ERROR: Wall position argument missing. Please run via run_wall_experiment.py.")
        return
        
    try:
        wall_pos_arg = float(sys.argv[1])
    except ValueError:
        print("ERROR: Wall position argument is not a valid number.")
        return

    # Read the traction data (solution vector components)
    traction_data = pd.read_csv(CSV_FILE)
    num_elements = len(traction_data)
    
    # Extract the element center coordinates from the Fortran output file
    collocation_points = extract_collocation_points(OUT_FILE, num_elements)
    
    if collocation_points is not None:
        # Pass the extracted argument to the visualization function
        visualize_traction(collocation_points, traction_data, wall_pos_arg)
        
if __name__ == "__main__":
    main()